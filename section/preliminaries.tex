\section{Preliminaries}

\sepfootnotecontent{sf:sparqlSpecification}{
    The SPARQL specification is available at the following link \newline\href{https://www.w3.org/TR/sparql11-query/}{https://www.w3.org/TR/sparql11-query/}
}

\sepfootnotecontent{sf:propertyPath}{
 We purposely ignored the inverse operator because we want to define the property path as a route of predicates and the inverse operator acts on the subject and object.
 Since its deletion does not change the expressivity of property we believe that their deletion does not affect the validity of our formalism.
}

\sepfootnotecontent{sf:blankNode}{
 A blank node is a unique idenfier with no IRI https://www.w3.org/wiki/BlankNodes.
}


\subsection{RDF knowledge graph and SPARQL queries}
Our work focuses on conjunctive queries $Q$ of RDF knowledge graph.
An RDF knowledge graph is composed of triples $t$ defined in Definition~\ref{def:triple} where the subjects and objects are nodes of the graph and the predicates are the edges.

\begin{definition}[RDF Triple]\label{def:triple}
    An RDF triple $t = (s,p,o)$ is formed by a subject term $s \in \mathcal{I} \cup \mathcal{B}$, a predicate term  $p \in \mathcal{I}$ and an object term $o \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{L}$
    where $\mathcal{I}$, $\mathcal{B}$, $\mathcal{L}$ are respectiverly the set of every possible IRI, blank node~\sepfootnote{sf:blankNode} and litteral.
\end{definition}

We consider two parts of $Q$~\sepfootnote{sf:sparqlSpecification} the basic graph pattern (BGP) defined in Definition~\ref{def:bgp} and the filter expressions as defined in Defintion~\ref{def:filterExpression}.
The atomic statement of a BGP is a triple pattern $tp$ defined at Definition~\ref{def:triplePattern}.

\begin{definition}[Triple pattern]\label{def:triplePattern}
    A triple pattern $tp = (s_{tp},p_{tp},o_{tp})$ is formed by a subject term $s_{tp} \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$, 
    a property path  $p_{tp}$ defined in Definition~\ref{def:propertyPath} and an object term  $o_{tp} \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{V}$ 
    where $\mathcal{V}$ is the set of every possible variable. 
\end{definition}

\begin{definition}[Property path]\label{def:propertyPath}
   A property path $p_{tp}$ is an expression that describe the route of predicate $p$ from $s_{tp}$ to $o_{tp}$.
   A property path in $tp$ is defined as follow~\sepfootnote{sf:propertyPath}:
   \begin{equation}
    p_{tp} ::= p \in \mathcal{I} | (p_{tpi}/p_{tpj}) | (p_{tpi}|p_{tpj}) | p_{tpi}* | p_{tpi}+ | p_{tpi}? | !p_{tpi}
   \end{equation}.
   The "$/$" operator chain two property path, the operate "$|$" define a possibility between $p_{tpi}$ and $p_{tpj}$.
   The "$!$" represent the negation of a path $p_{tpi}$ such as $p_{tpi} = \mathcal{I} \setminus p_{tpi}$.
   The "$*$", "$+$" and "$?$" are respectively, the repetition of 0 and more of $p_{tpi}$, 
   the repetition of 1 and more of $p_{tpi}$ and the presence of absence of $p_{tpi}$.
\end{definition}

\begin{definition}[BGP]\label{def:bgp}
 A BGP $B$ is a set of $tp$, \texttt{OPTIONAL} and \texttt{UNION} (both clause containing a sets of $tp$).
 $tp$ sets can be divided into star pattern $Q_{star}$ defined in Definition~\ref{def:starPattern} in a way 
 that $Q = \bigcup_{i\in S} Q_{star_i}$ given that $S$ is the set of every subject of the $tp$ in the $Q$.
\end{definition}

\begin{definition}[Filter expression]\label{def:filterExpression}
    A filter expression $F \rightarrow \{\mathrm{true}, \mathrm{false}\}$ is chain of boolean expressions $f_i(p_1, p_2...,p_n) \rightarrow \{\mathrm{true}, \mathrm{false}\}$ such that 
    $p_i \in \mathcal{I} \cup \mathcal{L} \cup (\mathcal{V}\in Q)$.
\end{definition}

\begin{definition}[Star pattern with dependencies]\label{def:starPattern}
We define a star pattern $Q_{star}$ as a set of $tp \in Q$ with the same subject such has $Q_{star} = \{ tp\in Q| s_{tp_1} = s_{tp_2} ... = s_{tp_n}\}$.
We define a star pattern with dependencies $Q_{starD}$ as the union between a star pattern $Q_{star} \in Q$ and other star patterns having as subjects
the objects of the initial star pattern such as $Q_{starD} = Q_{star} \cup \{tp \in Q| o_{i} = s_{tp} \land o_{i}\in tp_i \land tp_i  \in Q_{star}\}$.
\end{definition}

\subsection{Reachability criteria}

\emph{Reachability criteria} are boolean functions ($c_i$) restricting the dereferencing of links from the internal data source of the query engine.
They are take as parameters an RDF triple $t$ from the internal triple store, an dereferenciable IRI $i_d$ from $t$ and the a basic query pattern $B$ from the query~\cite{Hartig2012}.
If $c_i$ return $true$ then the query engine try to dererefence $i_d$.
A formalization is presented in equation~\ref{eq:reachabilityCriteria}.


\begin{equation}\label{eq:reachabilityCriteria}
c_i(t, i_d, B) \rightarrow \{\mathrm{true}, \mathrm{false}\}
\end{equation}

As they are boolean function reachability criteria can be chained together to form \emph{Composite reachability criteria}.
In this form a reachability criterion ($cp_i$) is said to \emph{prune} links if it is chained with an \emph{and} operator with the other criterion ($cd_i$) and it is said to \emph{discover} links if it chain with an \emph{or} operator.
Equation~\ref{eq:cReachabilityCriteria} formalize a composite reachability criterion $C$ with $nd$ discovery criteria and $np$ prunning criteria.

\begin{equation}\label{eq:cReachabilityCriteria}
    C(t, i_d, B)  = \bigvee_{i=0}^{nd}cd_i(t, i_d, B) \land \bigvee_{j=0}^{np}cp_j(t, i_d, B)
\end{equation}

The derefencing operation of the query stop when during an interation of the new element of the internal triple store no new $i_d$ has to be derefenced.

\subsection{RDF data shapes}
