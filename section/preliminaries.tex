\section{Preliminaries}

\sepfootnotecontent{sf:sparqlSpecification}{
    The SPARQL specification is available at the following link \newline\url{https://www.w3.org/TR/sparql11-query/}
}

\sepfootnotecontent{sf:blankNode}{
 A blank node is a unique idenfier with no IRI \url{https://www.w3.org/wiki/BlankNodes}.
}

\sepfootnotecontent{sf:propertyPathAlgebra}{
    \url{https://www.w3.org/TR/sparql11-query##PropertyPathPatterns}
}

\sepfootnotecontent{sf:recursiveShape}{
    In this formulation we ignore "inverse constraints" such as
    inverse triple constraint in ShEx \url{https://shex.io/shex-primer/index.html##inverse-properties}
    and SCHACL Inverse Paths \url{https://www.w3.org/TR/shacl##property-path-inverse} to avoid recurse 
    shape schemas~\cite{Corman2019}.
}


\subsection{RDF knowledge graph and SPARQL queries}
Our work focuses on conjunctive and disjunctive queries $Q$ of RDF knowledge graph.
The core element of a SPARQL query is the triple pattern which is define at Definition~\ref{def:triplePattern}.

\begin{definition}[Triple pattern]\label{def:triplePattern}
    A triple pattern $tp = (s, p , o)$ is formed by a subject term $s \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$, 
    a property path  $p$ as defined by  \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra} 
    and an object term  $o \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{V} \cup \mathcal{B}$ 
    where $\mathcal{V}$ is the set of every possible variable.
\end{definition}

We also define access function to get the subject of a triple pattern $tp$, 

\begin{equation}
    S: tp \rightarrow \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}
\end{equation}

.
SPARQL queries are performed over knowledge graphs (KG), composed of triples $t$ defined in Definition~\ref{def:triple} where the subjects and objects are graph nodes and the predicates are the edges.

\begin{definition}[RDF Triple]\label{def:triple}
    An RDF triple $t = (s,p,o)$ is formed by a subject term $s \in \mathcal{I} \cup \mathcal{B}$, a predicate term  $p \in \mathcal{I}$ and an object term $o \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{L}$
    where $\mathcal{I}$, $\mathcal{B}$, $\mathcal{L}$ are respectiverly the set of every possible IRI, blank node and literal.
\end{definition}

\iffalse
We define the basic graph pattern (BGP) of $Q$~\sepfootnote{sf:sparqlSpecification} in Definition~\ref{def:bgp}.
The atomic statement of a BGP is a triple pattern $tp$ defined at Definition~\ref{def:triplePattern}.

\begin{definition}[Triple pattern]\label{def:triplePattern}
    A triple pattern $tp = (s_{tp},p_{tp},o_{tp})$ is formed by a subject term $s_{tp} \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$, 
    a property path  $p_{tp}$ as defined by  \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra} 
    and an object term  $o_{tp} \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{V}$ 
    where $\mathcal{V}$ is the set of every possible variable. 
\end{definition}

\begin{definition}[Property path]\label{def:propertyPath}
   A property path $p_{tp}$~\cite{Kostylev2015} is an expression that describe the route of predicate $p$ from $s_{tp}$ to $o_{tp}$.
   \iffalse
   A property path in $tp$ is defined as follow:
   \begin{equation}
    p_{tp} ::= p \in \mathcal{I} | (p_{tpi}/p_{tpj}) | (p_{tpi}|p_{tpj}) | p_{tpi}* | p_{tpi}+ | p_{tpi}? | !p_{tpi}| p_{tpi}^{-}
   \end{equation}.
   The "$/$" operator chain two property path, the alternative operator "$|$" define a possibility between $p_{tpi}$ and $p_{tpj}$.
   The "$^-$" operator inverse the path from $s_{tp}$ to $o_{tp}$.
   The "$!$" represent the negation of a path $p_{tpi}$ such as $p_{tpi} = \mathcal{I} \setminus p_{tpi}$.
   The "$*$", "$+$" and "$?$", refered to in this paper as \emph{cardinality property paths}, are respectively; the repetition of 0 and more of $p_{tpi}$, 
   the repetition of 1 and more of $p_{tpi}$ and the presence or absence of $p_{tpi}$.
   \fi
\end{definition}

Property paths can be represented in SPARQL algebra as defined by \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra}
Notably, the alternative operator can be interpreted as a union, and the sequence operator as a chain of triple pattern.

\begin{definition}[BGP]\label{def:bgp}
 A BGP $B$ is a set of $tp$, \texttt{OPTIONAL} and \texttt{UNION} (both clause containing a sets of $tp$).
 $tp$ sets can be divided into star pattern $Q_{star}$ defined in Definition~\ref{def:starPattern} in a way 
 that $Q = Q_{star_{i-1}} \bowtie Q_{star_i} \forall i \in S$ given that $S$ is the set of every subject of the $tp$ in the $Q$.
\end{definition}
\fi

We also define star patterns and tree star patterns at Definition ~\ref{def:starPattern}.

\begin{definition}[Tree Star Pattern]\label{def:starPattern}
    We define a star pattern $Q_{star}$ as a set of $tp \in Q$~\cite{Karim2020} with the same subject such that 
    given a builder function 
    \begin{equation}
        BQ_{star}(s) = \{tp_i \in Q| S(tp_i) = s\}
    \end{equation}
    given $s \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$ then $Q_{star_s} = BQ_{star}(s)$.
    We define a tree star pattern $Q_{starT}$ as the union between a root star pattern $Q_{star_s}$
    and the star patterns having as subject term an object term of another star pattern in $Q_{starT}$.
    We define a function that returns every non-literal object terms of a star pattern
    \begin{equation}
        O_{star}: q \in Q \rightarrow  \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}
    \end{equation}
    and a function returning the subject of a star pattern
    \begin{equation}
        S_{star}: q \in Q \rightarrow  \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}
    \end{equation}

    We then define $Q_{starT}$ given a  set of partial tree star patterns $Q_{starPT}$
    \begin{equation}
        Q_{starT} = \bigcup_{q \in Q_{starPT}} q
    \end{equation}
    where $Q_{starPT}$ is formed with a root $Q_{star_s}$ by

    \begin{equation}
            Q_{starPT_i} =
        \begin{cases}
            \{Q_{star_s}\} & \text{if } i = 1 \\
            \{BQ_{star}(o)| o \in \bigcup_{q \in Q_{starPT_{i-1}}} O_{star}(q)\} & \text{if } i>1
        \end{cases}
    \end{equation}
    . 
    We propose a similar definition for the context of KG where we replace the query $Q$ by a KG $G$ and where the object 
    cannot be $v \in \mathcal{V}$ we denote it a tree star.

\end{definition}

\subsection{Reachability criteria}

\emph{Reachability criteria} are boolean functions ($c_i$) restricting the dereferencing of links from the internal data source of the query engine.
They take as parameters an RDF triple $t$ from an internal triple store, a dereferenceable IRI $iri$ from $t$, and the basic query pattern $B$ from the query~\cite{Hartig2012}.
If $c_i$ returns $true$, the query engine must try to dereference $iri$.
More formally
\begin{equation}\label{eq:reachabilityCriteria}
c_i(t, iri, B) \rightarrow \{\mathrm{true}, \mathrm{false}\}
\end{equation}
.
A query engine dereferencing operation stops when no new $iri$ has to be dereferenced during an iteration of the new triples in the internal triple store.

\subsection{RDF data shapes}
RDF data shapes, similar to data schemas, are constraints applied to RDF graphs.
In our context, shapes specify conditions that tree stars predicate and object terms must respect.
This work proposes an abstract formalization of shapes without distinction between different shape languages.

We define a shape
\begin{equation}
S = (E, op \in \{\mathrm{true},\mathrm{false}\})
\end{equation}

$E = \{e_1, e_2 ..., e_{n}\}$ is a set of $n$ shape expressions $e_i$.
Shape expressions are constraints on the triples of each tree star in $G$.
A KG must validate each expression $e \in E$ in the shape definition to satisfy a given shape.
$op$ describes whether a shape is open or closed.
An open shape allows extra undefined properties, respecting the shape expressions.
We define a set of constraint
\begin{equation}
    st = \{pc_p, oc_f, rs^a_b, n\}
\end{equation}
$pc_p$ and $oc_f$ are respectively constraint 
$c: t \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{B}  \rightarrow \{\mathrm{true}, \mathrm{false}\}$
on the predicate and the object of a tree star where the constraint is respected when returning $\mathrm{true}$.
$pc_p$ evaluates if a predicate term in a triple part of a tree star equals an IRI $p$.
$oc_f$ can enforce on the object of a tree star an RDF type, a shape, or a literal comparison on the object of a triple part of a tree star.
$rs^a_b = \{x \in \mathbb{N}_+ | a < x < b \}$ is a range on the number of triples in a tree star that must respect the $pc_p$ and $oc_f$ constraint.
$n \in \{\mathrm{true}, \mathrm{false}\}$ denote a negation of the constraint $pc_p$ and $oc_f$. 

A shape expression is defined by
\begin{equation}
 e_i ::= st \mid (e_j|e_k)
\end{equation}
where "$|$" denotes a disjunction between two shape expressions.

For $G$ to satisfy $S$, $G$ has to be analyzed as the union of all its tree stars such that $G = \bigcup_{g \in G_{starT}} g$.
With this perspective on $G$, the constraints $c$ in $e_i$ have to be evaluated on the triples $T = \{t| t \in G_{star_s} \in G_{starT_i}\}$ of the root tree star of every $G_{starT}$.
If all the constraints are satisfied for every $G_{starT}$, then $G$ satisfies $S$ denoted by $G \models S$.

\subsection{Decentralized Knowledge Graph}
We define a decentralized knowledge graph (DKG) as a knowledge graph (KG) $G$ materialized in a network of resources $R$.
A resource $r_i \in R$ contains a KG $g_i \subseteq G$ and is mapped to an IRI $iri_i$.
The network forms a graph where the resources $r_i$ are the nodes and the $iri_j \in t \in g$ are directed edges starting from $r_i$ to $r_j$.
$G$ is formed by the union of all the $g \in r$, such that $G = \bigcup_{i=0}^{n}g_i$ given $n$ resources.