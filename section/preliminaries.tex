\section{Preliminaries}

\sepfootnotecontent{sf:sparqlSpecification}{
    The SPARQL specification is available at the following link \newline\url{https://www.w3.org/TR/sparql11-query/}
}

\sepfootnotecontent{sf:blankNode}{
 A blank node is a unique idenfier with no IRI \url{https://www.w3.org/wiki/BlankNodes}.
}

\sepfootnotecontent{sf:propertyPathAlgebra}{
    \url{https://www.w3.org/TR/sparql11-query##PropertyPathPatterns}
}

\sepfootnotecontent{sf:recursiveShape}{
    In this formulation we ignore "inverse constraints" such as
    inverse triple constraint in ShEx \url{https://shex.io/shex-primer/index.html##inverse-properties}
    and SCHACL Inverse Paths \url{https://www.w3.org/TR/shacl##property-path-inverse} to avoid recurse 
    shape schemas~\cite{Corman2019}.
}


\subsection{RDF knowledge graph and SPARQL queries}
Our work focuses on conjunctive and disjunctive queries $Q$ of RDF knowledge graph.
An RDF knowledge graph is composed of triples $t$ defined in Definition~\ref{def:triple} where the subjects and objects are nodes of the graph and the predicates are the edges.

\begin{definition}[RDF Triple]\label{def:triple}
    An RDF triple $t = (s,p,o)$ is formed by a subject term $s \in \mathcal{I} \cup \mathcal{B}$, a predicate term  $p \in \mathcal{I}$ and an object term $o \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{L}$
    where $\mathcal{I}$, $\mathcal{B}$, $\mathcal{L}$ are respectiverly the set of every possible IRI, blank node~\sepfootnote{sf:blankNode} and literal.
\end{definition}

\begin{definition}[Triple pattern]\label{def:triplePattern}
    A triple pattern $tp = (s_{tp},p_{tp},o_{tp})$ is formed by a subject term $s_{tp} \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$, 
    a property path  $p_{tp}$ as defined by  \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra} 
    and an object term  $o_{tp} \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{V}$ 
    where $\mathcal{V}$ is the set of every possible variable. 
\end{definition}

\iffalse
We define the basic graph pattern (BGP) of $Q$~\sepfootnote{sf:sparqlSpecification} in Definition~\ref{def:bgp}.
The atomic statement of a BGP is a triple pattern $tp$ defined at Definition~\ref{def:triplePattern}.

\begin{definition}[Triple pattern]\label{def:triplePattern}
    A triple pattern $tp = (s_{tp},p_{tp},o_{tp})$ is formed by a subject term $s_{tp} \in \mathcal{I} \cup \mathcal{B} \cup \mathcal{V}$, 
    a property path  $p_{tp}$ as defined by  \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra} 
    and an object term  $o_{tp} \in \mathcal{I} \cup \mathcal{L} \cup \mathcal{V}$ 
    where $\mathcal{V}$ is the set of every possible variable. 
\end{definition}

\begin{definition}[Property path]\label{def:propertyPath}
   A property path $p_{tp}$~\cite{Kostylev2015} is an expression that describe the route of predicate $p$ from $s_{tp}$ to $o_{tp}$.
   \iffalse
   A property path in $tp$ is defined as follow:
   \begin{equation}
    p_{tp} ::= p \in \mathcal{I} | (p_{tpi}/p_{tpj}) | (p_{tpi}|p_{tpj}) | p_{tpi}* | p_{tpi}+ | p_{tpi}? | !p_{tpi}| p_{tpi}^{-}
   \end{equation}.
   The "$/$" operator chain two property path, the alternative operator "$|$" define a possibility between $p_{tpi}$ and $p_{tpj}$.
   The "$^-$" operator inverse the path from $s_{tp}$ to $o_{tp}$.
   The "$!$" represent the negation of a path $p_{tpi}$ such as $p_{tpi} = \mathcal{I} \setminus p_{tpi}$.
   The "$*$", "$+$" and "$?$", refered to in this paper as \emph{cardinality property paths}, are respectively; the repetition of 0 and more of $p_{tpi}$, 
   the repetition of 1 and more of $p_{tpi}$ and the presence or absence of $p_{tpi}$.
   \fi
\end{definition}

Property paths can be represented in SPARQL algebra as defined by \citeauthor{Kostylev2015} (Definition 2) and the SPARQL specification (section 18.2).~\sepfootnote{sf:propertyPathAlgebra}
Notably, the alternative operator can be interpreted as a union, and the sequence operator as a chain of triple pattern.

\begin{definition}[BGP]\label{def:bgp}
 A BGP $B$ is a set of $tp$, \texttt{OPTIONAL} and \texttt{UNION} (both clause containing a sets of $tp$).
 $tp$ sets can be divided into star pattern $Q_{star}$ defined in Definition~\ref{def:starPattern} in a way 
 that $Q = Q_{star_{i-1}} \bowtie Q_{star_i} \forall i \in S$ given that $S$ is the set of every subject of the $tp$ in the $Q$.
\end{definition}
\fi

\begin{definition}[Recursive Star pattern]\label{def:starPattern}
    We define a star pattern $Q_{star}$ as a set of $tp \in Q$ with the same subject such that $Q_{star} = \{ tp_i \in Q| s_{tp_1} = s_{tp_2} ... = s_{tp_m}\}$~\cite{Karim2020}
    where $m$ is the number of identical subjects.
    We define a recursive star pattern $Q_{starR}$ as the union between a root star pattern $Q_{star}$ and the $n$ deep star patterns
    having as a subject term, an object of the star pattern $Q_{starDp_{i-1,j}}$ where $n$ is the dept where no new star pattern can be generated,
    $i$ is the dept of the star pattern and $j$ is the index labeling the subject of the star pattern.
    We define $OS$ as a funtion return a set of every objects of the $tp$ in a star pattern.
    More formally, we define $Q_{starD}$ as
    \begin{equation}
        FQ(s) = Q_{starRl} = \{tp_i \in Q| s_{tp_1} = s_{tp_2} ... = s_{tp_m}\}
    \end{equation}

    \begin{multline}
        Q_{starRp_0} = \{Q_{star}\} \\
        Q_{starRp_1} = \{FQ(o) |\forall o \in \bigcup OS(Q_{starRp0})\} \\
        Q_{starRp_2} = \{FQ(o)|\forall o \in OS(Q_{starRp1})\} \\
        Q_{starRp_i} = \{FQ(o)|\forall o \in OS(Q_{starRp_{i-1}})\} \\
    \end{multline}

    \begin{equation}
        Q_{starD}= \bigcup Q_{starRp}
    \end{equation},
    where $m_i$ is the number of triple pattern in the star pattern $i$.
    $RS(Q_{starD})$ is a function giving the the subject variable of the $Q_{star} \in Q_{starD}$
    We also use the same terminology when dealing with triples instead of triple patterns.
\end{definition}

\subsection{Reachability criteria}

\emph{Reachability criteria} are boolean functions ($c_i$) restricting the dereferencing of links from the internal data source of the query engine.
They take as parameters an RDF triple $t$ from an internal triple store, a dereferenceable IRI $iri$ from $t$, and the basic query pattern $B$ from the query~\cite{Hartig2012}.
If $c_i$ returns $true$, the query engine must try to dereference $iri$.
A formalization is presented in equation~\ref{eq:reachabilityCriteria}.


\begin{equation}\label{eq:reachabilityCriteria}
c_i(t, iri, B) \rightarrow \{\mathrm{true}, \mathrm{false}\}
\end{equation}

The engine's dereferencing operation stops when no new $iri$ has to be dereferenced during an iteration of the new triples in the internal triple store.

\subsection{RDF data shapes}
RDF data shapes, similar to data schemas, are constraints applied to RDF graphs.
These shapes specify conditions that the predicates and objects of terms with the same subject must satisfy.
 We can interpret these shapes as defining a schema for star patterns with dependencies. 
 In this work, we propose an abstract formalization of shapes and make no distinction between different shape languages.~\sepfootnote{sf:recursiveShape}

We define a shape
\begin{equation}
S = (E, op \in \{\mathrm{true},\mathrm{false}\})
\end{equation}

with some similarities to \citeauthor{Abbas2018} definition.
$E = \{e_1, e_2 ..., e_{n}\}$ is a set of $n$ shape expression $e_i$.
Shape expressions are constraint on the triples in a knowledge graph (KG) $G$.
For a KG to satisfy a given shape, it must validate each expression $e_i \in E$ in the shape definition.
$op$ describes whether a shape is open or close.
An open shape allowed the presence of non-contradicting properties (with consideration of negative properties) not defined in $E$ in $G$.
A shape expression is defined by
\begin{align}
 e_i ::= (p, c, rs, n) | (e_j|e_k)
\end{align}
.
$e_i$ is a tuple of constraints on the predicate and the object of one triple of a star pattern with dependencies in a KG. 
A shape expressions define a predicate $p$ constraint that each star pattern with dependencies in $G$ must possess.
It also define a constraint on the object $c(o) \rightarrow \{\mathrm{true}, \mathrm{false}\}$.
The $c$ constraint can enforce an RDF type, shape or a literal comparison that the object term must respect.
$rs = \{x \in \mathbb{R}_+ | a < x < b \}$ is a range constraint on the number of object.
The shape expression can be a negation $n \in \{\mathrm{true}, \mathrm{false}\}$ meaning that the constraint $e_i$ must not be satisfied.
A shape expression can also be a disjunction, between two other shape expressions.

We denote a KG $G$ to satisify a shape $S$ by $G \models S$.
For $G$ to satisfy $S$ then when dividing $G$ in star pattern with dependencies such that $G = \bigcup Q_{starD}$,
the shape must validate each $Q_{starD_i}$ given that the root of the validation is the subject term of $Q_{star} \in Q_{starD_i}$.

\subsection{Decentralized Knowledge Graph}
We define a decentralized knowledge graph (DKG) as a knowledge graph (KG) $G$ materialized in a network of resources $R$.
A resource $r_i \in R$ contains a KG $g_i \subseteq G$ and is mapped to an IRI $iri_i$.
The network forms a graph where the resources $r_i$ are the nodes and the $iri_j \in t \in g$ are directed edges starting from $r_i$ to $r_j$.
$G$ is formed by the union of all the $g \in r$, such that $G = \bigcup_{i=0}^{n}g_i$ given $n$ resources.