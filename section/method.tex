\section{Approach}

\sepfootnotecontent{sf:shapeTarget}{
   It has to be noted that the concept of target and map of SHACL and ShEx does not apply, since it is always the whole knowledge graph that has to be valid.
}

\sepfootnotecontent{sf:shapeIndexURL}{
   \url{https://constraintautomaton.github.io/shape-index-specification/}
}

\subsection{Structured Linked Data Environments and Completeness}
From a holistic perspective, the web does not have a structure exploitable by query engines for optimization.
On the web, any document can be published at any location, and there is no index or trust mechanism to guide source selection.
Furthermore, there is no official mechanism for providing summary information about the content of data sources before their acquisition.
From a local perspective, a perspective where the web is divided into small subsections controlled by data providers, data publishers can implicitly or explicitly organize their data  
in a way that a query engine could exploit its organization for query optimization.
The concept of \emph{structural assumptions}~\cite{Taelman2023} has been theorized to optimize queries by exploiting the local structure of decentralized RDF datasets where the data providers 
guarantee the completeness of results related to their statement in a specific set of resources in an IRI domain~\cite{Bogaerts2021LinkTW}.

Structural assumptions have been shown to reduce the query execution time of multiple queries to the extent where the bottleneck of specific queries is not the number of HTTP requests but the suboptimal query plan~\cite{Taelman2023, eschauzier_quweda_linkqueue_2023}.
We can formalize the use of structural assumption to reduce query execution time as follows.
A query is executed over a DKG $G$ form by the union of all the $g \in r$ in the network $R$ of datasets having \emph{structural properties}~\cite{Taelman2023}.
The query engine has to build a KG $G^{\prime}$ in its internal data store from the  $g \in r$ by dereferencing resources in $R$ using reachability criteria and structural assumptions 
such as

\begin{equation}\label{eq:subsetDKG}
G^{\prime} \subseteq G
\end{equation}

and 

\begin{equation}\label{eq:evalQueryStructuralAssumption}
   [\![ Q ]\!]^{G^{\prime}} = [\![ Q ]\!]^{G}
\end{equation}
.
Because the $g \in G^{\prime}$ can only be acquired from the dereferencing of resources $r$, then a smaller $G^\prime$ implies that a lesser number of HTTP requests has been performed to answer a query
while returning the same results.
HTTP requests can be slow and unpredictable~\cite {hartig2016walking}; thus, executing less of them to answer a query can lead to a reduction of query execution time.
Additionally, a smaller internal data store leads to fewer triples to process during the joining operations.
The concept of structural assumption can also be used to define completeness differently than in the literature.
The state-of-the-art defined LTQP query completeness based on the acquisition of a set of resources derived from a reachability criteria~\cite{Hartig2012}.
However, the understanding of such completeness serves the purpose of defining query termination~\cite{Hartig2012}.
The definition Reachability criteria do not have the capacity to provide a metric to compare the performance of multiple traversal policies aims 
at reducing the size of $G^{\prime}$ while providing the same query results as defined by equations~\ref{eq:subsetDKG} and~\ref{eq:evalQueryStructuralAssumption}.
In the context of the World Wide Web (WWW), defining completeness based on results is not possible without the acquisition of the whole web due to the lack of guarantee about the location of the data; however,
in the context of a decentralized dataset with structural properties and associated structural assumptions, the traversal completeness of those datasets is defined outside of the query engine and thus can serve as a 
stable comparison concept regardless of the traversal policy of the query engine.
Such 




Furthermore, having a stable traversal completeness we can create a theorical results completeness metric, by considering the descentralized dataset as a centralized one that is the union 
of all the knowledge graph inside the ressources of the dataset $GD = \bigcup\limits_{i}^{n} g\in r_i$ given $n$ ressource $r$.
This, metric 

\begin{equation}\label{eq:metricResult}
   [\![ Q ]\!]^{G^{\prime}} = [\![ Q ]\!]^{G}
\end{equation}


\iffalse
While BQPs are syntactic objects, we shall use them as a represen-
tation of Linked Data queries which have a certain semantics. In the
remainder of this section we define this semantics. Due to the open-
ness and distributed nature of Webs such as the WWW we cannot
guarantee query results that are complete w.r.t. all Linked Data on
a Web. Nonetheless, we aim to provide a well-defined semantics.
Consequently, we have to limit our understanding of completeness.
However, instead of restricting ourselves to data from a fixed set
of sources selected or discovered beforehand, we introduce an ap-
proach that allows a query to make use of previously unknown data
and sources. Our definition of query semantics is based on a two-
phase approach: First, we define the part of a Web of Linked Data
that is reached by traversing links using the identifiers in a query
as a starting point. Then, we formalize the result of such a query
as the set of all valuations that map the query to a subset of all
data in the reachable part of the Web. Notice, while this two-phase
approach provides for a straightforward definition of the query se-
mantics in our model, it does not correspond to the actual query
execution strategy of integrating the traversal of data links into the
query execution process as illustrated in Section 2.

The analysis
of this implementation approach is particularly interesting because
this approach trades completeness of query results for the guarantee
that all query executions terminate as we shall see.


Hartig2012
\fi


\subsection{Shape index}
The concept of a shape index was already described in our publication \citetitle{tam2024opportunitiesshapebasedoptimizationlink}. 
However, it was not formalized.
A shape index $SI = (M, D)$, is a tuple where $M = \{s_1 \mapsto IRI_1, s_2 \mapsto IRI_2 \cdots, s_n \mapsto IRI_n\}$ is a mapping between RDF shapes and a set of IRI 
and where $D = IRI_0 \cup (\bigcup\limits_{i=1}^{n} IRI_i)$ is the domain of the index.
$IRI_0$ is the set of IRI that is inside of the domain of the index but where the IRI is not mapped in $M$
such that $iri \in IRI_0 \iff \nexists iri \in M(s_i)$.
When $IRI_0 = \emptyset$, then the shape index describes each resource of its domain and is denoted as a \emph{complete shape index}. 

A mapping between a shape and a set of IRI has implications in the distribution of the data in $D$.
when a shape is mapped to a set of $IRI$ then every triple of the knowledge graph $g^{\prime}$ such as $iri \mapsto g^{\prime} \in r \land iri \in IRI$
are validated by the shape such that $SE(s, g^{\prime}) = \text{true}$.~\sepfootnote{sf:shapeTarget}
Given that the shape mapping a set of IRI $IRI_i$ is close, then every set of triple in the resource associated with $D$ respecting the shape must be in a resource mapped to an IRI in $IRI_i$, 
such that given $G = \bigcup\limits_{j=1}^{n} g_j$ where $g_j$ is the knowledge graph containing every triple inside of the document with the IRI in the mapping $M$
then $SE(s, g) = true \iff g \mapsto iri \in IRI$.
A web specification of the shape index is also available online.~\sepfootnote{sf:shapeIndexURL}


\subsection{Expressing RDF Data shapes into SPARQL algebra}
A shape expression $e_i$ can be intuitively treated as a segment of a query~\cite{delva2023} more precisely of a star pattern with dependencies query.
A common approach for shape validation over an RDF graph is to convert shapes into SPARQL queries~\cite{labragayo2017validatingdescribinglinkeddata, Corman2019, spapeExpressionConvert}.

We are looking into transforming every $e_i$ into a $q_i$ such that an RDF data shape $S$ would be transform into a $Q = q_i \bowtie q_{i+1} ... \bowtie q_n$.
$Q$ must have the property that given a KG $G$ then 

\begin{equation}\label{eq:shapeSPARQL}
   SE(S,G) = \mathrm{true} \iff [\![ Q ]\!]^{G} =  G
\end{equation}
For every $G$ so.
We define in the following lines the transformation of a shape $S$ into a query $Q$ using the transformation $T(S,?x \in \mathcal{V})$. 


\iffalse
INSPIRE YOURSELF BY Corman2019 style

!!add having count in the query definition for the cardinalities!!
https://www.w3.org/TR/sparql11-query\#sparqlHavingClause
\fi

\begin{prop}\label{prop:triplePattern}
   In a shape expression $e_i$, $p$ with the combination of $r$ can be transformed into a query with one triple pattern with an associated \texttt{HAVING(COUNT(?o))} statement on the object of triple pattern.
   Such as $Q_{e_i} = \beta_{(|?o| \geq r[0] \land |?o| > r[1])}(?x, p, ?o)$, where we use $\beta$ for the  \texttt{HAVING} clause and $|?o|$ for the \texttt{COUNT} clause. 
\end{prop}

\begin{prop}
   In a shape expression $e_i$ , $c$ can be transformed into a filter expression targeting $?o$ if the constraint is a comparison or enforce a type on an object such that
   $q_{i} = \sigma{c(?o)}(?x, p, ?o)$. 
   If $c$ enforce a shape on $?o$ then $q_i$ must be form by the join of a query derived by $e_i$ with $c = \mathrm{true}$ and a query dervided from the shape of $c$ where $?o$ is the subject 
   such that $q_{i}= \sigma{c(?o)}(?x, p, ?o) \bowtie T(S_c,?o)$ given $S_c$ is the shape related to $c$.
\end{prop}

\begin{prop}
   In a shape expression $e_i = e_j|e_k$ then the expression can be transform into the union between two queries
   $Q_{e_i}(x,o)= Q_{e_j}(x,o_j) \cup Q_{e_k}(x,o_k)$.
\end{prop}

\begin{prop}
   In a shape expression when $n= \mathrm{true}$ then $\neg Q_{e_i}(x,o)$.
\end{prop}

\begin{prop}
   A shape $S$ is transform into $Q_{E} = Q_{e_1} \bowtie Q_{e_2} ... \bowtie Q_{e_{n_e}}$ given $n_e$ shape expressions and a close shapes $op = \mathrm{false}$.
\end{prop}

\begin{prop}
   A open shape $S$ ($op = \mathrm{true}$) is transform into $Q_{E} = (?x, ?p, ?o) -  (Q_{e_1} \bowtie Q_{e_2} ... \bowtie Q_{e_{n_e}}| n\in e_i = \mathrm{true}) $ where $Q_{e_i}$.
\end{prop}

\subsection{Query shape containment}
The query shape containment problem is similar to the query containment problem as it 
try to determine if the possible answers of the star pattern with dependencies query are contained in any instance of data respecting an RDF data shape.
We can divide the query shape contaiment problem into two category the \emph{strict} and \emph{loose} containment.
The difference between the problems lies into their handling of the union of queries, optional triple patterns and cardinality of property path.


We consider an RDF data shapes as start pattern with dependencies such as 
\begin{equation}
   Q_{shape} = Q_{body} \bigvee Q_{nested body}
\end{equation}
because the subject of a shape is always a single variable 

CITE FOR PROPERTY PATH PARTICULARLY THE NEGATION \cite{Kostylev2015}



\subsection{Online source selection in environments with a shape index}

The shape index by solving the query containment problem can be expressed as a structural assumption.
... define the algorithm