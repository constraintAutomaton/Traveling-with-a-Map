\section{Approach}

\sepfootnotecontent{sf:shapeTarget}{
   It has to be noted that the concept of target and map of SHACL and ShEx does not apply, since it is always the whole knowledge graph that has to be valid.
}

\sepfootnotecontent{sf:shapeIndexURL}{
   \url{https://constraintautomaton.github.io/shape-index-specification/}
}

\sepfootnotecontent{sf:ssf_project}{
   The paper \citetitle{delva2023} additional material also proposes a script to convert SCHACL shapes into SPARQL queries.
   \url{https://github.com/MaximeJakubowski/ssf_project}
}

\subsection{Structured Linked Data Environments and Completeness}\label{sec:slde}
From a holistic perspective, the web does not have a structure exploitable by query engines for optimization.
On the web, any document can be published at any location, and there is no index or trust mechanism to guide source selection.
Furthermore, there is no official mechanism for providing summary information about the content of data sources before their acquisition.
From a local perspective, a perspective where the web is divided into small subsections controlled by data providers, data publishers can implicitly or explicitly organize their data  
in a way that a query engine could exploit its organization for optimization.
The concept of \emph{structural assumptions}~\cite{Taelman2023} has been theorized to optimize queries by exploiting the local structure of decentralized RDF datasets where the data providers 
guarantee the completeness of results related to their statement in a specific set of resources in an IRI domain~\cite{Bogaerts2021LinkTW}.

Structural assumptions have been shown to reduce the query execution time of multiple queries to the extent that the bottleneck of specific queries is not the number of HTTP requests but the suboptimal query plan~\cite{Taelman2023, eschauzier_quweda_linkqueue_2023}.
We propose to reduce the number of HTTP requests by using more restricting reachability criteria~\cite{Hartig2012} while ensuring the same completeness of results.
We formalize our general approach as follow.
A query is executed over a DKG $G$ formed by the union of all the $g \in r$ in the network $R$.
The query engine has to build a KG $G^{\prime}$ in its internal data store from the  $g \in r$ by dereferencing resources in $R$ such that

\begin{equation}\label{eq:subsetDKG}
G^{\prime} \subseteq G
\end{equation}

and 

\begin{equation}\label{eq:evalQueryStructuralAssumption}
   [\![ Q ]\!]^{G^{\prime}} = [\![ Q ]\!]^{G}
\end{equation}
.
Because the $g \in G^{\prime}$ can only be acquired from the dereferencing of resources $r \in R$, a smaller $G^\prime$ implies that a lesser number of HTTP requests has been performed to answer a query
returning the same results.
HTTP requests can be slow and unpredictable~\cite{hartig2016walking}; thus, executing fewer requests to answer a query can lead to a reduction of query execution time.
Additionally, a smaller internal data store leads to fewer triples to process during the joining operations, which can further contribute to the reduction of query execution time.

To define a less selective reachability to produce $G^{\prime}$, we propose extending the reachability criteria by formalizing chain of criterion in a concept called \emph{composite reachability criteria}.
In this form, a reachability criterion ($cp_i$) is said to \emph{prune} links if it is chained with an \emph{and} operator, and ($cd_i$) is said to \emph{discover} links if it chain with an \emph{or} operator.
A reachability $cp_i \in C$ should act upon all the links that have yet to be dereferenced as well as on the incoming links.
Equation~\ref{eq:cReachabilityCriteria} formalize a composite reachability criterion $C$ with $nd$ discovery criteria and $np$ prunning criteria.

\begin{equation}\label{eq:cReachabilityCriteria}
    C(t, i_d, B)  = \bigvee Cd \land \bigvee Cp
\end{equation}
where $Cd$ is the set of every $cd_i(t, i_d, B)$ and $Cp$ the set of every $cp_i(t, i_d, B)$ used by the engine. 

We pose that a query engine can change its reachability criterion during the execution and that a change in  reachability affect not only the future link follow,
but also the links that has not been dereferenced.
\iffalse
Maybe refer to the link queue here in a footnote.
\fi

\iffalse
In the context of the World Wide Web (WWW), defining completeness based on results is not possible because it necessitate the acquisition of the whole web.
However, in the context of a decentralized dataset with structural properties and associated structural assumptions,
the traversal completeness of those datasets is defined outside of the query engine and thus can serve as a 
stable comparison concept regardless of the traversal policy of the engine.
Hence, for each dataset with structural properties, it is possible to compute a theoretical result completeness.
If we suppose a finite network of connected datasets that are discoverable with a specified reachability criterion such as \texttt{cmatch},
Then, it is possible to establish the completeness of the subset of the query targeting information in the network.



Furthermore, having a stable traversal completeness we can create a theorical results completeness metric, by considering the descentralized dataset as a centralized one that is the union 
of all the knowledge graph inside the ressources of the dataset $GD = \bigcup\limits_{i}^{n} g\in r_i$ given $n$ ressource $r$.
This, metric 

\begin{equation}\label{eq:metricResult}
   [\![ Q ]\!]^{G^{\prime}} = [\![ Q ]\!]^{G}
\end{equation}

\fi 



\iffalse
While BQPs are syntactic objects, we shall use them as a represen-
tation of Linked Data queries which have a certain semantics. In the
remainder of this section we define this semantics. Due to the open-
ness and distributed nature of Webs such as the WWW we cannot
guarantee query results that are complete w.r.t. all Linked Data on
a Web. Nonetheless, we aim to provide a well-defined semantics.
Consequently, we have to limit our understanding of completeness.
However, instead of restricting ourselves to data from a fixed set
of sources selected or discovered beforehand, we introduce an ap-
proach that allows a query to make use of previously unknown data
and sources. Our definition of query semantics is based on a two-
phase approach: First, we define the part of a Web of Linked Data
that is reached by traversing links using the identifiers in a query
as a starting point. Then, we formalize the result of such a query
as the set of all valuations that map the query to a subset of all
data in the reachable part of the Web. Notice, while this two-phase
approach provides for a straightforward definition of the query se-
mantics in our model, it does not correspond to the actual query
execution strategy of integrating the traversal of data links into the
query execution process as illustrated in Section 2.

The analysis
of this implementation approach is particularly interesting because
this approach trades completeness of query results for the guarantee
that all query executions terminate as we shall see.


Hartig2012
\fi


\subsection{Shape Index}
We propose to use a descentralized dataset summary method as the support mechanism for our prunning reachability crition, called Shape Index~\cite{tam2024opportunitiesshapebasedoptimizationlink}.
It consists of mapping the content of a decentralized dataset with RDF data shapes.
Because the web is a highly dynamic environment and data providers might need high flexibility, shape indexes enable open shapes as mapping keys.
In practice, a shape index could look like this: A data provider exposes personal data containing movie recommendations, bookmark metadata and friend lists.
The data provider might have a more or less structured movie recommendation sub-dataset; thus, they use an open shape; they might have structured bookmarks and friend list, thus they 
use close shapes.

The concept of a shape index was already described in the publication \citetitle{tam2024opportunitiesshapebasedoptimizationlink}. 
However, we made some modifications and formalize it.
A shape index 
\begin{equation}\label{eq:shapeIndex}
   SI = (M, D)
\end{equation}
, is a tuple where $M = \{s_1 \mapsto IRI_1, s_2 \mapsto IRI_2 \cdots, s_n \mapsto IRI_n\}$ is a mapping between RDF shapes and a set of IRI 
and where $D = \bigcup\limits_{i=1}^{n} IRI_i$ is the domain of the index.
A shape index \emph{must} map every resource in $D$.
We denote a shape index as \emph{complete} when every shape $s_i \in M$ is closed and \emph{incomplete} otherwise.

A mapping between a shape and a set of IRI has implications in the distribution of the data in $D$.
when a shape is mapped to a set of $IRI$ then every triple of the knowledge graph $g^{\prime}$ such as $iri \mapsto g^{\prime} \in r \land iri \in IRI$
are validated by the shape such that $g^{\prime} \models s$.~\sepfootnote{sf:shapeTarget}
Given that the shape mapping a set of IRI $IRI_i$ is close, then every set of triple in the resource associated with $D$ respecting the shape must be in a resource mapped to an IRI in $IRI_i$, 
such that given $G = \bigcup\limits_{j=1}^{n} g_j$ where $g_j$ is the knowledge graph containing every triple inside of the document with the IRI in the mapping $M$
then $g \models s \iff g \mapsto iri \in IRI$.
A web specification of the shape index is also available online.~\sepfootnote{sf:shapeIndexURL}

\subsection{Online source selection in environments with a shape index}

A decentralized dataset exposing a shape index give the opportunity to a query engine to reduce its search domain by evaluating which resources are query-relevant.
The shape descriptions and the constraint on the distribution of the data make it so that within a domain $D$ of a shape index $SI$, the query engine can
determine a priori to the traversal of $D$, which subdomain $d \subseteq D$ will contain data that is query relevant.
To formalize our approach, we use the concept of composite reachability criteria described in section~\ref{sec:slde} and of the source selectors of the subweb specification formalization~\cite{Bogaerts2021LinkTW, Taelman2023}.

We pose that a query engine has a composite reachability $C_t$ at any time $t$ able to query an SLDE, such as if the engine were not to change its reachability
until $t_f$ the end of the query execution such that the equation \ref{eq:evalQueryStructuralAssumption} would still hold when considering that $G$ from equation \ref{eq:subsetDKG} is aquire with the reachability 
at the beginning of the execution $C_{0}$.


We pose that $C_0$ has at least a discovery criteria $cd_{\text{shape index}}$ that follow links leading to shape indexes.
Let's consider that the predicate \texttt{si:shapeIndexLocation} indicate that the object of the triple is the location of the shape index 
of the dataset, thus we can define a criterion $cd_{\text{shape index}} = \{o|\forall s \langle \text{si:shapeIndexLocation} \rangle \}$.

A reachability $C_{tsi}$ is created after the dereferencing of a shape index.
This reachability must accept the links $IRI_d$ that are query relevant, and prune the links $IRI_p$.
To determine $IRI_d$ and $IRI_p$ a query-shape containement ($\sqsubseteq_{qs}$) is performed.
The problem is defined at section \ref{sec:containment}.
We define
\begin{gather}
   IRI_d = \bigcup \{ M_i(s_j) | \forall (Q_{starD} \in B) \sqsubseteq_{qs}  s_j \} \\
   IRI_p = \bigcup \{ M_i(s_j) | \forall (Q_{starD} \in B) \not\sqsubseteq_{qs}  s_j \}
\end{gather}
given a shape index $SI_i$ with a mapping $M_i$.
From those sets of links we define two new reachability criteria;
\begin{gather}
   cd_{si}(t, i_d, B) = i_d \in IRI_d \\
   cp_{si}(t, i_d, B) = i_d \not\in IRI_p
\end{gather}
.
the new reachability $C_{tsi}$ is created by taking the $Cd$ and $Cp$ of $C_{tsi - 1}$ and adding
$cd_{si}$ and $cp_{si}$ to the corresponding set. 

\iffalse
\begin{algorithm}
   \caption{Dynamic reachability generation algorithm with a shape index}\label{alg:shapeIndex}
   \begin{algorithmic}
      \REQUIRE Given a Shape Index $(M, D)$ and a query $Q$
      \ENSURE $IRI_d$ a set of IRI leading to query relevant sources and $IRI_p$ a set of IRI leading to non query relevant sources

      \STATE Divide the $Q$ into a set of star pattern with dependencies $Q_{sd}$ such that $Q = q_{sd,1}  \bowtie q_{sd,2} ... \bowtie q_{sd,n}$ given $n$  $q_{sd,i}$.
      \STATE $IRI_d = \{\}$
      \STATE $ContainedQueries = \{\}$
      \STATE $IRI_p = \{\}$

      \FORALL{$q_{sd} \in Q_{sd}$}
         \FORALL{$(s, iri) \in M$}
            \IF{$q_{sd} \sqsubseteq_l T(s)$}
               \STATE $IRI_d = IRI_d \cup \{iri\}$
               \STATE $ContainedQueries = ContainedQueries \cup \{q_{sd}\}$   
            \ENDIF
         \ENDFOR
      \ENDFOR
      
      

      \IF{$(IRI_0 \in D) = \emptyset$ \OR $Q_{sd} \setminus containedQueries = \emptyset$}
         \STATE $IRI_p = D \setminus IRI_d$
      \ELSE
         \STATE $IRI_m = \{\text{Codomain of }m_i(s)| \forall m_i \in M \}$
         \STATE $IRI_p = IRI_m \setminus IRI_d$
      \ENDIF
   \end{algorithmic}
\end{algorithm}
\fi


\subsection{Expressing RDF Data shapes into SPARQL algebra}\label{sec:shape2SPARQL}

A shape expression $e_i$ can be intuitively treated as a segment of a query~\cite{delva2023}.
A common approach for shape validation over an RDF graph is to convert shapes into SPARQL queries~\cite{labragayo2017validatingdescribinglinkeddata, Corman2019,Prestamo2023, spapeExpressionConvert}.~\sepfootnote{sf:ssf_project}

For our query-shape containment problem we are looking into transforming our shapes $S$ into queries $Q_s =  q_i \bowtie q_{i+1} ... \bowtie q_n$ by transforming each $e_i$ of $s$ in a $q_i$.
We are looking into creating a query $Q_s$ with the following property
\begin{equation}\label{eq:shapeSPARQL}
   G \models S \iff [\![ Q_s ]\!]^{G} =  G
\end{equation}
For every $G$.

Our definition is aimed at close shapes because we are not looking into validating data but into containment since an open shape can validate 
For any $G$ that contains at least the constraint specified by $S$, we simplify the fact that if we neglect negative statements, any query can be contained in such a shape.
The intuition behind equation~\ref{eq:shapeSPARQL} is that we are looking to produce a query that simulates the behavior of a shape.
It is natural from the definition of shape languages. It has been shown in the literature that shape constraint can be transformed into a combination of triple patterns, filter expressions, and other SPARQL fragments.
Thus, if we can establish a mapping between the constraints of $S$ in terms of query fragments, a query targeting $G$ should return $G$ if every triple of the 
$G$ respects the constraint of the shape.
We define in the following lines the transformation of a shape $S$ into a query $Q_s$ using the transformation $T(S,?x)$ and $t(e_i, ?x) = q_i$ where every 
symbol with a $?$ prefix is a variable in $\mathcal{V}$.


\iffalse
INSPIRE YOURSELF BY Corman2019 style

We might want to reference that

https://labra.weso.es/publication/2023_kg_subsets_pregel/
https://labra.weso.es/publication/2024_extracting_shapes_consolidator/

https://labra.weso.es/publication/2023_rdf_data_integration/

ssf_project Maxime

https://github.com/MaximeJakubowski/ssf_project/blob/master/ssf/sparql_conformance.py

\fi

\begin{prop}\label{prop:triplePattern}
   In a shape expression $e_i$, $p$ and $rs$ can be transformed into a query consisting of one triple pattern with an associated \texttt{GROUP BY ?x HAVING(COUNT(?o))} statement on the object of triple pattern,
   such that
   $Q_{e_i} = \beta_{?x, (|?o| \in rs)}(?x, p, ?o)$,
   where $\beta$ is a \texttt{GROUP BY ?x HAVING} clause and $|?o|$ is a \texttt{COUNT} clause. 
\end{prop}

\begin{prop}
   In a shape expression $e_i$ , $c$ can be transformed into a filter expression targeting $?o$ if the constraint is a comparison or enforce a type on an object such that
   $q_{i} = \sigma_{c(?o)}(?x, p, ?o)$. 
   If $c$ enforces a shape on $?o$, then $q_i$ must be formed by the join of a query derived by $e_i$ with $c = \mathrm{true}$ and a query derived from the shape targeted in $c$ where $?o$ is the subject 
   such that $q_{i}= (?x, p, ?o) \bowtie T(S_c,?o)$ given $S_c$ is the shape related to $c$.
\end{prop}

\begin{prop}
   In a shape expression $e_i = e_j|e_k$ the expression can be transform into the union between two queries
   $q_{i} = t(e_j, ?x) \cup t(e_k, ?x)$.
\end{prop}

\begin{prop}
   In a shape expression $e$ when $n= \mathrm{true}$ then the query $q_i$ must be negated such that $\neg q_i$.
\end{prop}

\begin{prop}
   A shape closed shape ($op = \mathrm{false}$) $S$ can be transform into $Q = t(e_1, ?x) \bowtie t(e_2, ?x) ... \bowtie t(e_{n_e}, ?x)$ given $n_e$ shape expressions.
\end{prop}

\begin{prop}
   A open shape $S$ ($op = \mathrm{true}$) is transform into $Q = (?x, ?p, ?o) -  (t(e_1, ?x) \bowtie  t(e_2, ?x) ... \bowtie t(e_{n_e}, ?x)| n\in e_i = \mathrm{true}) $ where $Q_{e_i}$.
\end{prop}

\subsection{Query shape containment}\label{sec:containment}

We propose to perform a form of query-shape containment as a source selection mechanism.
We start the analysis by dividing a query $Q$ into its star pattern with dependencies $q_{starD_i}$ such that $Q = q_{starD_0} \bowtie q_{starD_1} ... \bowtie q_{starD_n}$
and transforming a shape $S$ into a query $Q_s$ via the transformation $T$ define in the previous section.




The previous section shows that $Q_s$ follows a query template of a star pattern with dependencies, where the subjects and objects are always variables, and the predicate is always an IRI.
In this paper, we will ignore the filter expressions and clauses and use this query template to solve the query containment problem.
We are presenting two variances of the query shape containment problem, one for general source discovery that we denote \emph{loose} containment $\sqsubseteq_l$ and 
another denote \emph{strict} $\sqsubseteq$ that could be used for determining information similar to exclusive group~\cite{Schwarte2011}. 
Intuitively, the query containment problem does not seem suited for online source selection because its complexity is NP-complete~\cite{Spasi2023}.
However, the complexity is in terms of the size of both queries, which tend to be small.
Additionally, in practical use cases, polynomial algorithms exist~\cite{Doan2012}; 
thus, it is a valid mechanism for source selection, and our experiment results will further demonstrate this proposition.

\begin{definition}[Loose containment]\label{def:looseContainment}
We define a losse containment between a query $q_i$ and a shape $Q_s$ as determining if one path $q_{pi} \subseteq q_i$ of the query $q_i = \bigcup_{i=0}^{n} q_{pi}$ given $n$ path is contained in 
$Q_s$ such has $\exists (q_{pi} \sqsubseteq  Q_s) = q_{i} \sqsubseteq_l  Q_s$.
\end{definition}

The loose containment problem is used to determine if part of a query is contained in shape,
it is necessary to determine if at least one path is contained inside a shape to avoid losing potential partial results.
Due to the exclusivity constraint of the shape index, the engine has a guarantee that a path $q_{pi} \sqsubseteq Q_s$ will be located at a specific location in the domain of a shape index.
A simpler possibility for source selection without avoiding the loss of partial results is to use property matching;
however, this method is less selective because RDF vocabulary tends to be reused by multiple entities~\cite{Stuckenschmidt2004, Harth2010},
which can lead to selecting multiple sources that would be query-relevant.
There are some particularities that property paths introduce in the query containment problem~\cite{Kostylev2015}.
As presented in the preliminaries, most property paths can be rewritten into SPARQL algebra; with the use of an alternative path "$/$", multiple unions can be added to the query.
The property that changes the most the query containment problem is the negative path ("$!$")~\cite{Kostylev2015},
however, in our context, negative paths have little effect because we are looking for one path that is contained inside $Q_s$.

\iffalse
LET MAKE AN ALGORITHM and analyse the complexity
\fi


\begin{definition}[Strict containment]\label{def:strictContainment}
We define a strict containment between a query $q_i$ and a shape $Q_s$ when $q_i$ is contain in $Q_s$ such has $q_{i} \sqsubseteq Q_s$.
\end{definition}

The version of the query containment is algorith have the same definition than a classic query containment problem, however due to the 
particular query template of $Q_s$, the complexity of the problem is simpler.

This problem could be used in the context of federated query to determine exclusive groups, given that the federation exposes a shape index, 
also, in the context of LTQP, where some data source would have a SPARQL interface, this concept of containment could be used to send a large segment of the query to the endpoint 
minimizing communication and joining operation costs of the client engine.

With this version, the negative path also has a lesser impact than the noted typical query containment problem because the container query 
always have a single IRI as its predicate; hence, a $q_i$ using a negated property path will be contained in $Q_s$.

\iffalse
The query shape containment problem is similar to the query containment problem as it 
try to determine if the possible answers of the star pattern with dependencies query are contained in any instance of data respecting an RDF data shape.
We can divide the query shape contaiment problem into two category the \emph{strict} and \emph{loose} containment.
The difference between the problems lies into their handling of the union of queries, optional triple patterns and cardinality of property path.


We consider an RDF data shapes as start pattern with dependencies such as 
\begin{equation}
   Q_{shape} = Q_{body} \bigvee Q_{nested body}
\end{equation}
because the subject of a shape is always a single variable 

CITE FOR PROPERTY PATH PARTICULARLY THE NEGATION \cite{Kostylev2015}


The shape index by solving the query containment problem can be expressed as a structural assumption.
... define the algorithm
\fi